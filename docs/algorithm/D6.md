# 动态规划
动态规划是一种将一个大问题拆分成小问题，逐步求解的算法思想.
> 动态规划五部曲：
> 1、dp数组以及下标的含义
> 2、递推公式
> 3、dp数组如何初始化
> 4、遍历顺序
> \* 打印dp数组（debug）
## 求最少硬币数量问题
目标是找到最少的硬币数量来凑出一个给定的金额

思路： 
在最少硬币数量问题中，我们可以将问题拆分成一个个小问题，逐步求解，最终得到最少的硬币数量方案。
我们可以使用一个数组 dp 来记录求解过程中的中间结果，其中 dp[i] 表示凑出金额 i 需要的最少硬币数量。对于一个金额为 i 的问题，我们可以考虑使用一枚硬币 coin 来凑出金额 i，这样就可以将问题拆分成金额为 i-coin 的子问题，也就是：dp[i] = dp[i-coin] + 1
实现：
```js
function coinChange(coins, amount) {
    // 创建dp数组，初始值为无限大
  const dp = Array(amount).fill(Infinity) 
  // 金额为0时，需要0个硬币
  dp[0] = 0
  // 依次枚举1 ---> amount 需要用到的硬币
  for(let i = 1; i <= amount, i ++) {
    // 枚举每个硬币面值，和这个硬币面值数量为1情况
    for(let j = 0; i < coins.length, j++) {
        // 如果金额小于硬币面值，并且当前硬币面值数量为1的方案已经算出来了
        if(i >= coins[j] && dp[i], dp[i - coins[j]] !== Infinity) {
            // 根据状态转移方程dp[i] = min(dp[i], dp[i-j]+1)来更新dp[i]的值。
        dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1)
        }
    }
  }
   // 如果dp[amount]仍然为Infinity，说明无法凑出金额amount
  // 否则，返回dp[amount]表示凑出金额amount所需的最少硬币数
  return dp[amount] === Infinity ? -1 : dp[amount]
}
```

## 01背包问题

